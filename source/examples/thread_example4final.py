# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'dialog_ui.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
sys.path.append('qtdesigner')
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
import resource_rc
import datetime
import time

class ServerThread(QThread):
    """
       Avvio del comando a Oracle
    """
    signalStatus = pyqtSignal(str)

    def __init__(self):
        super(ServerThread, self).__init__()          
        self.completato = False

    def run(self):                
        time.sleep(10)                
        self.completato = True

class WorkerThread(QThread):
    """
       Thread che avvia il vero thread di esecuzione comando a Oracle
    """
    signalStatus = pyqtSignal(str)

    def run(self):
        # inizio lavoro
        start_time = datetime.datetime.now()             
        v_1a_volta = True
        v_fine_lavoro = False
        # avvio un ciclo infinito
        while not v_fine_lavoro:
            # calcolo il tempo trascorso
            elapsed_time = datetime.datetime.now() - start_time        
            
            # se prima volta, avvio il lavoro sul server...
            if v_1a_volta:
                v_1a_volta = False
                self.server_thread = ServerThread()        
                self.server_thread.start()                
                prec_elapsed_seconds = elapsed_time.total_seconds()
                        
            if round(elapsed_time.total_seconds() - prec_elapsed_seconds) == 1:                                 
                minuti, secondi = divmod(elapsed_time.seconds + elapsed_time.days * 86400, 60)                                
                self.signalStatus.emit(f"Exec time: {minuti:02}:{secondi:02}")
                prec_elapsed_seconds = elapsed_time.total_seconds()
                if self.server_thread.completato:
                    v_fine_lavoro = True
            
            # attesa di 100 millisecondi per non impegnare troppo la cpu su questo ciclo
            self.msleep(100)  
        
        # lavoro terminato emetto segnale di fine che verrà catturato dalla funzione progress
        self.signalStatus.emit("END_JOB_OK")

class SendCommandToOracle(QDialog):
    """
       Questa classe visualizza una dialog con una progressbar di avanzamento lavoro e lancia il comando Oracle 
       ricevuto in input
       Siccome tale comando lascia libero il programma solo al termine, nel durante, si vuole che l'utente possa
       interrompere l'operazione. Per fare questo in questa classe ci sono due thread. Il primo si occupa di lanciare
       in un secondo thread il comando vero e proprio verso Oracle.
    """
    def __init__(self):
        super().__init__()
        # definizione layout della finestra di dialogo
        self.setWindowTitle("...please wait...")    
        self.resize(320, 81)
        icon = QIcon()
        icon.addPixmap(QPixmap(":/icons/icons/MSql.ico"), QIcon.Normal, QIcon.Off)
        self.setWindowIcon(icon)
        self.gridLayout = QGridLayout(self)        
        # progressbar (il testo è invisibile all'inizio per questioni estetiche ma poi diventerà visibile)
        self.progressbar = QProgressBar(self)        
        self.progressbar.setTextVisible(False)        
        self.progressbar.setMinimum(0)
        self.progressbar.setMaximum(100)    
        self.gridLayout.addWidget(self.progressbar, 0, 0, 1, 1)
        # zona del bottone di interruzione dell'operazione
        self.buttonBox = QDialogButtonBox(self)
        self.buttonBox.setOrientation(Qt.Horizontal)
        self.buttonBox.setStandardButtons(QDialogButtonBox.Cancel)        
        self.gridLayout.addWidget(self.buttonBox, 1, 0, 1, 1)        
        # definizione del segnale di interruzione
        self.buttonBox.rejected.connect(self.cancel_worker) # type: ignore
        # definizione del primo thread 
        self.worker_thread = WorkerThread()
        self.worker_thread.signalStatus.connect(self.update_progress)
        # connessione dei segnali
        QMetaObject.connectSlotsByName(self)
        # lancio del primo thread al cui interno verrà lanciato il secondo thread che esegue il comando vero e proprio
        self.worker_thread.start()

    def cancel_worker(self):
        """ 
           L'utente ha richiesto la cancellazione dell'operazione....
        """
        self.worker_thread.terminate()
        self.progressbar.setValue(0)
        self.close()

    def update_progress(self, status):
        """
           Si riceve il segnale di aggiornamento dell'interfaccia...la progressbar viene aggiornata nel tempo di esecuzione
           se il segnale contiene END_JOB_OK viene chiuso tutto
        """
        if status == 'END_JOB_OK':
            self.close()
        else:
            if not self.progressbar.isTextVisible():
                self.progressbar.setTextVisible(True)        
            v_value = self.progressbar.value()
            if v_value >= 99:
                v_value = 10
            else:
                v_value += 10
            self.progressbar.setValue(v_value)
            self.progressbar.setFormat(status)             
            self.progressbar.setAlignment(Qt.AlignCenter)

###
# TEST
###
if __name__ == "__main__":
    import sys
    app = QApplication(sys.argv)    
    ui = SendCommandToOracle()    
    ui.show()
    sys.exit(app.exec_())